--- zgv/src/readbmp.c~	Tue May 29 02:21:15 2001
+++ zgv/src/readbmp.c	Sat Sep 29 16:28:45 2001
@@ -65,7 +65,7 @@
   FILE *in;
   int i, j;
   int iswindows = 0;
-  int dummy, count, done;
+  int dummy, count, done, bytepp, bytes_in_image;
   unsigned char *buf;
   unsigned char read[2];
   unsigned char *p;
@@ -83,15 +83,15 @@
     return (_PICERR_NOFILE);
 
   if ((buf = malloc (54)) == NULL)
-    return (_PICERR_NOMEM);
+    CLOSE_AND_RET(_PICERR_NOMEM);
 
   fread (buf, 1, 26, in);
 
   if (buf[0] != 'B')
-    return (_PICERR_BADMAGIC);
+    CLOSE_AND_RET(_PICERR_BADMAGIC);
 
   if (buf[1] != 'M')
-    return (_PICERR_BADMAGIC);
+    CLOSE_AND_RET(_PICERR_BADMAGIC);
 
   read_bch(&bch,buf+14);
 
@@ -104,7 +104,7 @@
     }
 
   if ((p = calloc (768,1)) == NULL)
-    return (_PICERR_NOMEM);
+    CLOSE_AND_RET(_PICERR_NOMEM);
 
   /* only actually used if using dither 8-bit display of 24-bit image,
    * but defined always
@@ -129,10 +129,14 @@
       pp->height = h = bch.bcHeight;
       pp->bpp = bch.bcBitCount;
       palsize=(palsize-26)/3;
+      
+      /* in case these are used later -rjm */
+      bih.biWidth=bch.bcWidth;
+      bih.biHeight=bch.bcHeight;
     }
   
   if (w == 0 || h == 0 || palsize > 256)
-    return (_PICERR_CORRUPT);
+    CLOSE_AND_RET(_PICERR_CORRUPT);
 
   if ((pp->bpp >> 3) < 3)
     *output_type = 1;
@@ -162,23 +166,30 @@
 	w = w * 3;
       break;
     default:
-      return (_PICERR_CORRUPT);
+      CLOSE_AND_RET(_PICERR_CORRUPT);
     }
 
   if (w == 0 || h == 0)
-    return (_PICERR_CORRUPT);
+    CLOSE_AND_RET(_PICERR_CORRUPT);
 
   if ((*pal = calloc (768,1)) == NULL)
-    return (_PICERR_NOMEM);
+    CLOSE_AND_RET(_PICERR_NOMEM);
 
+  bytepp=1;
   if ((pp->bpp == 24) && (*output_type == 3))
-    dummy = 3;
-  else
-    dummy = 1;
-  if ((work_bmap = *bmap = malloc (w * (h + 2) * dummy)) == NULL)
-    return (_PICERR_NOMEM);
-  memset (*bmap, 0, w * (h + 2) * dummy);
-
+    bytepp = 3;
+  if ((work_bmap = *bmap = calloc (w * (h + 2) * bytepp,1)) == NULL)
+    CLOSE_AND_RET(_PICERR_NOMEM);
+
+  bytes_in_image=w*h*bytepp;
+
+  /* this should be used whenever adding a file-input-dependent amount
+   * to the current position pointer. It's > rather than >= so that we
+   * can point *just* past the end having read in data, which is ok.
+   */
+#define FAIL_FOR_BAD_OFFSET(cur,add) \
+  do {if((cur)+(add)>bytes_in_image) CLOSE_AND_RET(_PICERR_CORRUPT);} while(0)
+  
   /* if you look at the stuff below, `p' is the palette
    * which would be right to free by the time we're actually
    * reading the image, so...
@@ -274,6 +285,7 @@
 	      fread (read, 1, 2, in);
 	      if (*read)
 		{
+                  FAIL_FOR_BAD_OFFSET(ptr-*bmap,*read);
 		  i = 0;
 		  do
 		    {
@@ -299,15 +311,16 @@
 		done = 1;
 	      else if (read[1] == 2)
 		{
-		  /* This isn't really tested */
-		  ptr += fgetc (in) + bih.biWidth * fgetc (in);
+                int ofs=fgetc (in) + bih.biWidth * fgetc (in);
+                FAIL_FOR_BAD_OFFSET(ptr-*bmap,ofs);
+                /* This isn't really tested */
+		ptr += ofs;
 		}
 	      else
 		{
-		  dptr = hptr = malloc (read[1] >> 1);
-		  fread (dptr, 1, read[1] >> 1, in);
-		  if (read[1] % 4 > 1)
-		    dummy = fgetc (in);
+                  FAIL_FOR_BAD_OFFSET(ptr-*bmap,read[1]);
+		  dptr = hptr = malloc (((read[1]+3)>>2) << 1);
+		  fread (dptr, 1, ((read[1]+3)>>2) << 1, in);
 		  i = 0;
 		  do
 		    {
@@ -327,7 +340,7 @@
 		}
 	    }
 	  if (_PICERR_NOMEM == flip (*bmap, bih.biWidth, bih.biHeight))
-	    return (_PICERR_NOMEM);
+	    CLOSE_AND_RET(_PICERR_NOMEM);
 	}
       /*pp->width = w;*/		/* believed bogus -rjm 2001 Apr 10 */
       pp->numcols= 16;
@@ -354,9 +367,12 @@
       if ((!iswindows) || (bih.biCompression == 0))
 	for (i = h - 1; i >= 0; i--)
 	  {
-	    fread (ptr + pp->width * i, 1, w, in);
+	    fread (ptr + pp->width * i, 1, pp->width, in);
 	    if (howfarfunc != NULL)
 	      howfarfunc (h - i, h);
+            if(w>pp->width)
+              for(j=pp->width;j<w;j++)
+                fgetc(in);
 	  }
       else
 	/* 8bit RLE compressed */
@@ -367,11 +383,14 @@
 	    {
 	      fread (read, 1, 2, in);
 	      if (read[0])
+                {
+                FAIL_FOR_BAD_OFFSET(ptr-*bmap,read[0]);
 		for (i = 0; i < (int) read[0]; i++)
 		  {
 		    *ptr = read[1];
 		    ptr++;
 		  }
+                }
 	      else if (read[1] == 0)
 		{
 		  if (howfarfunc != NULL)
@@ -381,17 +400,22 @@
 	      else if (read[1] == 1)
 		done = 1;
 	      else if (read[1] == 2)
-		ptr += fgetc (in) + bih.biWidth * fgetc (in);
+                {
+                int ofs=fgetc (in) + bih.biWidth * fgetc (in);
+                FAIL_FOR_BAD_OFFSET(ptr-*bmap,ofs);
+		ptr += ofs;
+                }
 	      else
 		{
-		  fread (ptr, 1, read[1], in);
-		  if (read[1] % 2)
-		    fgetc (in);
-		  ptr += read[1];
+                FAIL_FOR_BAD_OFFSET(ptr-*bmap,read[1]);
+		fread (ptr, 1, read[1], in);
+                if (read[1] % 2)
+                  fgetc (in);
+                ptr += read[1];
 		}
 	    }
 	  if (_PICERR_NOMEM == flip (*bmap, bih.biWidth, bih.biHeight))
-	    return (_PICERR_NOMEM);
+	    CLOSE_AND_RET(_PICERR_NOMEM);
 	}
       pp->numcols= 256;
       break;
@@ -413,7 +437,7 @@
           *output_type=1;
 	  /* Truecolor BMPs and 8-bit display */
 	  if (ditherinit (pp->width) == 0)
-	    return (_PICERR_NOMEM);
+	    CLOSE_AND_RET(_PICERR_NOMEM);
 	  for (i = 1; i <= h; i++)
 	    {
 	      hptr = ptr + pp->width * i;
@@ -424,7 +448,7 @@
 	    }
 	  ditherfinish ();
 	  if (_PICERR_NOMEM == flip (*bmap, pp->width, pp->height))
-	    return (_PICERR_NOMEM);
+	    CLOSE_AND_RET(_PICERR_NOMEM);
 	  pp->bpp = 8;
           pp->numcols= 256;
 	}
